#include <iostream>
#include <stack>
using namespace std;

struct Leksema //Структура, описывающая любое число или операцию
{
	char type; // 0 для чисел, "+" для операции сложения и т.д. (Stack_n)
	double value; //Значение (только для чисел). У операций значение всегда "0" (Stack_o)
};

bool Maths(stack <Leksema>& Stack_n, stack <Leksema>& Stack_o, Leksema& item) { //Математическая функция, которая производит расчеты
	//Функция имеет тип bool, чтобы при возникновении какой-либо ошибки возвращать "false"
	double a, b, c;
	a = Stack_n.top().value; //Берется верхнее число из стека с числами 'a'
	Stack_n.pop(); //Удаляется верхнее число из стека с числами 'a'(чтобы взять второе число)
	switch (Stack_o.top().type) {  //Проверяется тип верхней операции из стека с операциями
	case '+': //Если тип верхней операции из стека с операциями сложение
		b = Stack_n.top().value;//Берем верхнее число из стека с числами, которое уже является 'b'
		Stack_n.pop(); //Удаляется верхнее число из стека с числами 'b'(для того чтобы результат '+' положить обратно в стек)
		c = a + b;//сохраняем результат
		//чтобы занести значение 'c' в стэк item нужно прописать заново тип и значение
		item.type = '0';//тип
		item.value = c;//значение
		Stack_n.push(item); //Результат операции кладется обратно в стек с числами 'c'
		Stack_o.pop();//Удаляется отработанная операция
		break;//останавливаем цикл 

	case '-':
		b = Stack_n.top().value;
		Stack_n.pop();
		c = b - a;//Меняем местами 'a' и 'b' для правильной работы стека
		item.type = '0';
		item.value = c;
		Stack_n.push(item);
		Stack_o.pop();
		break;

	case '*':
		b = Stack_n.top().value;
		Stack_n.pop();
		c = a * b;
		item.type = '0';
		item.value = c;
		Stack_n.push(item);
		Stack_o.pop();
		break;

	case '/':
		b = Stack_n.top().value;
		if (a == 0) {
			cout << "На 0 делить нельзя!";
			return false;
		}
		else {
			Stack_n.pop();
			c = (b / a); // Меняем местами 'a' и 'b' для правильной работы стека
			item.type = '0';
			item.value = c;
			Stack_n.push(item);
			Stack_o.pop();
			break;
		}
	default://Проверка . есле ввели не '+,-,/,*' а какой-то другой симво, то выводим ошибку
		cout << "Ошибка!";
		return false;
		break;
	}
	return true;
}
int getRang(char Ch) { //Функция возвращает приоритет операции: "1" для сложения и вычитания, "2" для умножения и деления и т.д.
	if (Ch == '+' || Ch == '-')
		return 1;
	if (Ch == '*' || Ch == '/')
		return 2;
	else 
		return 0;
}
int main()
{
	setlocale(LC_ALL, "rus");
	cout << "    Пограмма - калькулятор!"<< endl;
	cout << "    Калькулятор решает такие задачи как * , / , - , + ." << endl;
	cout << "    И возможность воспользоваться ( ) ." << endl;
	cout << "    Прошу вводить выражение корректно"<< endl;
	cout << "    Введи выражение: \n";
	char Ch; //Переменная, в которую будет записываться текущий обрабатываемый символ
	double value;//переменная для числа
	bool flag = 1; //Нужен для того, чтобы программа поняла, что в выражении с переди стоит '-'
	stack <Leksema> Stack_n; //Стек с числами
	stack <Leksema> Stack_o; //Стек с операциями
	Leksema item; //Объект типа Leksema (инициализация элемента) 
	while (true) 
	{
		Ch = cin.peek(); //Смотрим на первый символ//вроде коробочки со всеми возможными значениями; посмотрели в нее, но ничего не взяли
		if (Ch == '\n')
			break; //Если достигнут конец строки, выходим из цикла
		if (Ch == ' ') { //Игнорирование пробелов
			cin.ignore();
			continue;
		}
		if (Ch >= '0' && Ch <= '9' || Ch == '-' && flag == 1)//Если прочитано число
		{ 
			cin >> value;
			item.type = '0';    //инициализация числа
			item.value = value; //возьмет все числа в себя (24.3455 или 2345675)
			Stack_n.push(item); //Число помещается в стек с числами
			flag = 0;
			continue;
		}
		if (Ch == '+' || Ch == '-' && flag == 0 || Ch == '*' || Ch == '/') { //Если прочитана операция
			if (Stack_o.size() == 0) { //Если стек с операциями пуст
				item.type = Ch;
				item.value = 0; //операция никакого значения не предпологает
				Stack_o.push(item); //Результат операции кладется в стек с операциями (возвращается на вершину)
				cin.ignore(); //для игнорирования одного символа, чтобы заглянуть снова в cin.peek()
				continue; //переходим к следущей итерации (расфасовка)
			}
			if (Stack_o.size() != 0 && getRang(Ch) > getRang(Stack_o.top().type)) { //Если стек с операциями НЕ пуст, но приоритет текущей операции выше
				item.type = Ch;                                                     //верхней операции в стеке с операциями (если операции равны + и - или / и *)
				item.value = 0;
				Stack_o.push(item); //Операция кладется в стек с операциями 
				cin.ignore();
				continue;
			}
			if (Stack_o.size() != 0 && getRang(Ch) <= getRang(Stack_o.top().type)) {//Если стек с операциями НЕ пуст, но приоритет текущей операции ниже либо равен верхней операции в стеке с операциями
				if (Maths(Stack_n, Stack_o, item) == false) { //Если функция вернет "false", то прекращаем работу
					return 0;
				}
				continue;
			}
		}
		if (Ch == '(') { //Если прочитана открывающаяся скобка
			item.type = Ch;
			item.value = 0;
			Stack_o.push(item); //Операция кладется в стек с операциями
			cin.ignore();
			continue;
		}
		if (Ch == ')') { //Если прочитана закрывающаяся скобка не кладем в стек
			while (Stack_o.top().type != '(') 
			{
				if (Maths(Stack_n, Stack_o, item) == false) { //Если функция вернет "false", то прекращаем работу
					return 0;
				}
				else continue; //Если все хорошо	
			}
			Stack_o.pop();
			cin.ignore();//для того, чтобы перейти к следущей операции. когда посчитали выражение в скобках
			continue;
		}
		else { //Если прочитан какой-то странный символ
			cout << "\nНеверно введено выражение!\n";;
			return 0;
		}
	}
	while (Stack_o.size() != 0) //Вызываем матем. функцию до тех пор, пока в стеке с операциями не будет 0 элементов
	{ 
		if (Maths(Stack_n, Stack_o, item) == false) { //Если функция вернет "false", то прекращаем работу
			return 0;
		}
		else continue; //Если все хорошо	
	}
	cout << "   Ответ: " << Stack_n.top().value << endl; //Выводим ответ
	return 0;
}